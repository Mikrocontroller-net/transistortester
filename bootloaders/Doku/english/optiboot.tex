\chapter{The optiboot boot-loader for AVR Micro-controllers}

\section*{}
The optiboot Boot-loader has been created with C language by Peter Knight and
Bill Westfield. I have used the version 6.2 as base
for the here described revised Assembler version.
I would like to underline, that I did not reinvent the
optiboot boot-loader. I have just done some optimizing.
Many adaptions to several target processors and special
board level systems are present with the version 6.2.
The program use parts of the STK500 communication protocol,
which is released with AVR061~\cite{stk500} from Atmel.


\section{Changes and enhancements to the version 6.2}
Basically I have translated the total program in the assembler language
and have rebuild the process for generating the .hex file
with a bash shell script, so that the program length will
be processed automatically to select the start address of the boot-loader
and set the right fuses for that program length.
The selected solution generates some variables during some
interim steps, which are required to solve the steps
to select the right start address and the right fuses.
The start address of the boot-loader for any target processor
depends on the present flash size, the flash requirement
of the boot-loader code and the tile size, which is supported
by the target processor for bootlace.
The tile size means the smallest boot-loader size, which can be supported
by the selected target processor.


For processors like the ATtiny84, which don't support the boot-loader start function,
the page size of the flash memory is used for this calculation.
For the ATtiny84 this are 64 Bytes. Therefore the start address of
the boot-loader is always located at the begin of a flash page.

For all other supported target processors the boot-loader area can be
selected with the fuse bits BOOTSZ1 and BOOTSZ0 (each with the values 0 and 1).
If you put together the both bits, you get a coded boot-loader size
with values between 0 and 3.
Always the value of 3 select the smallest possible boot-loader area.
A value of 2 select a double size, the value 1 the quadruple size
and the value 0 select a size of eight times the smallest size.
The table~\ref{tab:bootsz} at page~\pageref{tab:bootsz} shows a 
overview for the several target processors.

\section{Features of the optiboot Assembler version}

To avoid many pitfalls when creating an executable boot loader,
the creation of the boot loader file was largely automated.
In addition, settings are also checked and the generation is
canceled with a corresponding error message,
if, for example, the selected operating frequency (AVR\_FREQ) does not match the
fuse setting (CKSEL, CKDIV8) for the clock.
Receiving program data for optiboot is currently only possible via a serial interface. \\

Below are some of the features listed for the optiboot bootloader:
\begin{itemize}

\item {Supports a large number of AVRs, allmost all have been tested for functionality.}

\item {Support the data load for the EEprom memory.}

\item {Fits in 512 Byte Flash in most cases.}

\item {The required fuse setting is changed automatically according to the actual program size.}

\item {The start address, which depends on the program size and the AVR model,
	is automatically calculated and displayed on the screen.}

\item {All serial interfaces available with the respective AVR processor
         can be chosen freely. The first UART is always the default.}

\item {Can emulate the serial interface via software.
	With that options you can also use ATtiny processores without a UART.
        In addition, the TX and RX pins can be freely selected with SOFT\_UART.}

\item {With the SOFT\_UART feature you can select a serial communication with only on AVR pin (RXD and TXD are same).
	The Hardware UART can not use this feature, because the RXD and TXD pins are fixed to the
		manufactor selected pins.}

\item {The Baud rate can be adjusted automatically by the optiboot program.
	For that feature the Baud time is measured by analysing the first incomming serial data byte.
	Different methods of this baud time measurement can be choosed.
	Normally you must deselect the LED Flash function to fit
	the optiboot program data within 512 byte Flash.}

\item {Can be used with AVRs without the bootloader support.\\
        This VIRTUAL\_BOOT\_PARTITION feature of course also
	be used for AVRs, which has the bootloader support.
	The optiboot program  gets bigger, but can then start at every flash memory page.}

\item {By default, a connected LED flashes three times (LED\_START\_FLASHES=3).
	When serial data arrives, the blinking is stopped immediately.}

\item {Instead of the LED flashing at startup, you can also let the LED light up when waiting
	for serial data (LED\_DATA\_FLASH=1).
       By setting LED\_DATA\_FLASH=4 you call select a permanent lit LED.
		The watchdog reset will turn the LED off in this case.}

\item {You can also choose the adapted C-sources to generate the optiboot bootloader.
	Most of the features are possible with this selection also.
	Of course the generated optiboot program will be bigger!
	Please note, that you have to select the EEprom support with the C-source.}

\item {The length of the generated optiboot depends only on the selected AVR processor and the selected options.
	The version of the installed avr-gcc has no effect, if you use the assembler source.
	So a later check of the installed bootloader can be easier done,
	even with another PC.}

\item {Supports the frequency adjustment of the build in AVR RC-oscillator.
	For some problematic processors this feature enables the use of a
	bootloader with a fix baud rate.}

\end{itemize}

The next features affects only the build process of the boot bootloader:

\begin{itemize}

\item {The amount of the screen output iduring the generating of the optiboot program
	can be adjusted with the system variable VerboseLev. 
	The value for VerboseLev can be between 1 and 4, the normal value is 2.}

\item {The screen output can also be colored with the system variable WITH\_COLORS=1.
	If the variable is set to WITH\_COLORS=2, you get a unformatted text on screen.}

\item {The generationg of the optiboot program is controlled by the bash script build\_hex.sh.
	This script will read the required AVR data from the text file avr\_params.def .
	In the same avr\_params.def the script will find the default setting for the fuses and
		other parameters like operating frequency and baud rate for every supported AVR.}

\item {For every supported AVR processor the build\_hex.sh script can find a matching
	file in the avr\_pins directory, where the pin layout of this processor is fixed.
	Because some processors have the same pin layout, some of the AVRs are grouped together.
	In the matching file the default pin for the LED can be found.
	For processors without UART the default pins for RXD and TXD for the software UART
	solution is specified.}

\item {The generating of the optiboot program runs at a Linux System with installed avr packages.
	You can also use a Windows10 system, when you install the Arduino package und additional
	one or more packages, which install the required commands like bash, bc, echo and other tools.
	Tested is the generation at a Windows10 laptop with installed Arduino and Cygwin64 package.}

\item {The selected parameters for the generating of the optiboot bootloader are logged at the
	end of the .lst file and also in a separate .log file.
	You can see the report with the command cat <filename>.log .}

\item {Installing the optiboot bootloader at a respective AVR can be done with the program avrdude and
	a connected ISP-programmer.
	To initiate this task only a additional ISP=1 is required at the make call.
	With a ISP=2 at the make call you can operate a verify run of avrdude.
	Additionally a read out of the total flash memory of the AVR is possible
	with ISP=3. A ISP=4 will read the complete EEprom data from your AVR processor.}

\end{itemize}


\section{Automatic size adaption in the optiboot Makefile}

The boot-loader start address and the required boot-loader size will
be adapted automatically with the bash script build\_hex.sh, wich
is called by the Makefile.
For the calculation some interim variables are created,
which is only possible together with some Linux tools:

\begin{description}
\item [bash] a powerfull command interpreter for running the script files.
\item [bc] a simple calculator, which can operate with input and output-
values in decimal and hexadecimal values.
\item [cat] put the file content to the standard output.
\item [cut] can select part of lines of a text.
\item [echo] shows the specified text at standard output.
\item [grep] shows only lines of a text file which contain the specified string.
\item [tr] can replace or erase characters.
\end{description}

Until now the functions of the bash script is only tested with a Linux System and
with Windows10 together with installed Cygwin64 and Arduino packages.
The new optiboot system does not create .dat interim Files.

Here are the names of the used script files:
\begin{description}

\item [build\_hex.sh] take the settings from the Makefile and produce a
matching optiboot hex-file in Intel format.
The build\_hex.sh scripts call some helping scripts as get\_avr\_params.sh,
avr\_family.sh, show\_led\_pin.sh, show\_rx\_pin.sh and show\_tx\_pin.sh .
If the variable ISP is set, also the script program\_target is called.

\item [program\_target.sh] is called from build\_hex.sh, to check and correct
the hfuse and efuse settings. 
If the configuration result to another number of used bootpages, the BOOTSZ bits
of the ATmega must be changed. The bits are depending on the AVR model
in the hfuse or efuse byte, which does not make the correction easier.
After the required corrections the avrdude program is called with
the script only\_avrdude.sh .

\item [only\_avrdude.sh] makes only one avrdude call with the params
given by the variable DUDE\_PARAMS .
For check of the parameters the call is reported at the terminal.
If the avrdude call returns with an error, the script give some common hints
for error search. At a Linux system a additional search of probably matching serial
interfaces is done.

\item [find\_serials.sh] will search possible interface named for USB-serial converters
at a Linux system.
For this task are matching integrated chips available, which are named by the
Linux driver beginning with /dev/ttyUSB .
There are also some software emulations available at special mikrocontrollers,
which has a integrated USB interface. You can access these Interfaces with
names beginning with /tty/ACM .
For each found Interface the script will check, if a access is possible for you.
For that you must be a member in the group, which is allowed to access the
interface (in most cases dialout).
This script will only called from only\_avrdude, if avrdude returns with error.
You can call this script also by command bash ./find\_serials.sh
For a Windows system this scipt is useless, use the device manager of Windows instead
to find serial interfaces with name COMx .

\item [get\_avr\_params.sh] find for the MCU\_TARGET specified AVR processor
 all required parameters like flash size, the size of a flash page and the
size of a bootloader page. Additionally some default values like operating frequency,
baud rate and fuse settings are set, if not specified by user.
The source file for these settings is avr\_params.def.

\item [avr\_family.sh] build a group name for some AVR processors with identical pin layout.
Usually the group name is identical to the member with the biggest flash
(atmega328 for atmega16 or atmega88).

\item [show\_led\_pin.sh] find the LED pin, which is the default for this processor or group
in the file avr\_pins/<group>.pins
A message is shown to explain this selection. If the user has selected another pin for the
LED, this pin is reported.

\item [show\_rx\_pin.sh] report the selected RX pin for incomming serial data.
If the user did not specify a special selection for SOFT\_UART, the pin is taken from
the avr\_pins/<group>.pins file.

\item [show\_tx\_pin.sh] report the selected TX pin for outgoing serial data.
If the user did not specify a special selection for SOFT\_UART, the pin is taken from
the avr\_pins/<group>.pins file.

\item [baudcheck.tmp.sh] is created during the run of the build\_hex.sh script
with a C-Preprocessor call from the baudcheck.S file.
It is executed in the same run to give you information about the selected
baud rate state.

\end{description}

\section{target selection for the optiboot Makefile}

There can exist different configurations for the same processor type.
The table~\ref{tab:processors} shows some basic configuration
for several target processors.
You can select some parameters also with the make call or by setting
a environment variable of the shell.
These settings will allways replace the default selections.
There are two main variable names, which are given to the bash shell script
build\_hex.sh , TARGET and MCU\_TARGET. The MCU\_TARGET must specify a valid
AVR processor name. The TARGET variable specifies a free selectable name,
but is usually same as the MCU\_TARGET of specify a board name.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | c | c | c | c | c | c | c |}
    \hline
             Name  & MCU & AVR\_ & total & Flash & BP\_ & LFUSE & HFUSE & EFUSE  \\
                   &     & FREQ  & Flash & page  & LEN  &       &       &        \\
                   &     &       &  size & size  &      &       &       &        \\
    \hline
    \hline
         attiny84 & t84   & 16M? &  8K   &  64   & (64) &  62   &  DF   & FE \\
    \hline
         atmega8  & m8    & 16M  &  8K   &  64   & 256  &  BF   &  CC   &  - \\
    \hline
         atmega88 & m88   & 16M  &  8K   &  64   & 256  &  FF   &  DD   &  04 \\
    \hline
       atmega16   & m16   & 16M  &  16K  & 128   & 256  &  FF   &  9C   &  - \\
    \hline
       atmega168  &  m168  & 16M  &  16K & 128   & 256  &  FC   &  DD   &  04 \\
       atmega168p &  m168p & 16M  &  16K & 128   & 256  &  FC   &  DD   &  04 \\
    \hline
       atmega32   &  m32   & 16M  &  16K & 128   & 256  &  BF   &  CE   &  - \\
    \hline
       atmega328  &  m328  & 16M  &  32K & 128   & 512  &  FF   &  DE   &  05 \\
       atmega328p & m328p & 16M  &  32K  & 128   & 512  &  FF   &  DE   &  05 \\
    \hline
       atmega644p & m644p & 16M  &  64K  & 256   & 512  &  F7   &  DE   &  05 \\
    \hline
     atmega1284p & m1284p & 16M  & 128K  & 256   & 512  &  F7   &  DE   &  05 \\
    \hline
     atmega1280  & m1280  & 16M  &  128K & 256   & 1K   &  FF   &  DE   &  05 \\
    \hline
    \end{tabular}
  \end{center}
  \caption{some Processor targets for optiboot Makefile}
  \label{tab:processors}
\end{table}

All size values are shown in byte units, the values for fuses are shown with hexadecimal values.
The frequency values must be specified in Hz units, 16M is the same as 16000000 Hz.
The standard baud rate of the serial interface is 115200 in most cases.

Additional to the universal processor configurations you can also select
configurations for special boards or operational environment.
The table~\ref{tab:boards} shows the different adjustments.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | c | c | c | c | c | c | c | c | }
    \hline
             Name  & MCU & AVR\_ & BP\_ & L     & H     & E     & BAUD\_ & LED & SOFT\_ \\
                   &     & FREQ  & LEN  &  FUSE & FUSE  &  FUSE & RATE &     & UART \\
    \hline
    \hline
       luminet     & t84 &  1M   & 64v &  F7   &  DD   &  04   & 9600 & 0x  &  -   \\

    \hline
         virboot8  & m8    & 16M & 64v &       &       &       &      &     &      \\
    \hline
       diecimila  &  m168 & (16M) &     &  F7   &  DD   &  04   &      & 3x  &  -   \\
       lilypad    &  m168  & 8M  &      &  E2   &  DD   &  04   &  -   & 3x  &  -   \\
       pro8       &  m168  & 16M &      &  F7   &  C6   &  04   &  -   & 3x  &  -   \\
       pro16      &  m168  & 16M &      &  F7   &  DD   &  04   &  -   & 3x  &  -   \\
       pro20      &  m168  & 16M &      &  F7   &  DC   &  04   &  -   & 3x  &  -   \\
    atmega168p\_lp&  m168  & 16M &      &  FF   &  DD   &  04   &  -   &     &  -   \\
   xplained168pb  &  m168  &(16M)&      &       &       &      & 57600 &     &      \\
    \hline
       virboot328  & m328p & 16M & 128v &       &       &       &      &     &  -   \\
    atmega328\_pro8& m328p & 8M  &      &  FF   &  DE   &  05   &  -   & 3x  &  -   \\
   xplained328pb  &  m168  &(16M)&      &       &       &      & 57600 &     &      \\
   xplained328p   &  m168  &(16M)&      &       &       &      & 57600 &     &      \\
    \hline
        wildfire  & m1284p & 16M &      &       &       &      &   -   & 3xB5 &      \\
    \hline
       mega1280    & m1280 & 16M &      &  FF   &  DE   &  05   &  -   &     &  -   \\
    \hline
    \end{tabular}
  \end{center}
  \caption{configured targets for the optiboot Makefile}
  \label{tab:boards}
\end{table}

\section{The Options for the optiboot Makefile}

With the options you can select the feature of the optiboot boot-loader.
For example you can select with the option SOFT\_UART, that a software solution
is used for the serial communication.
Without this option a integrated hardware UART is used for serial communication.
The pin TX (Transmit) is used for serial output and the pin RX (Receive) is used
for serial input. If more than one UART is present at the target processor,
the first interface with the number 0 is used.
But you can also select every other present UART by specify the number with
the option UART (UART=1 for the second present UART).
For the hardware UART interfaces the pins for transmit and receive are fixed
to the specific pins. For the serial communication with software you can
select any pins, which are able to do digital input and output.
More details for the available options you can find in the tables~\ref{tab:options1}
and \ref{tab:options2}

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | l |}
    \hline
   Name of        & Example         & Function                                            \\
   the Option         &                &                                                     \\
    \hline
    \hline
    F\_CPU         & F\_CPU=8000000 & Tell the program the clock frequency of the processor. \\
                   &                & The value is specified in Hz units (cycles per second). \\
                   &                & The example specifies a frequency of 8 MHz. \\
    \hline
    BAUD\_RATE     & BAUD\_         & Specifies the baud-rate for the serial communication. \\
                   &  RATE=9600     & Always 8 data bits without parity is used. \\
                   &                & Values below 100 will select a measurement and adaptation \\
                   &                & of the baudrate with different technique. \\
    \hline
    SOFT\_UART     & SOFT\_UART=1   & Select a software solution for the serial communication. \\
    \hline
    UART\_RX        & UART\_RX=D0   & Specifies the port and bit number used for the serial input. \\
                   &                & The example select bit 0 of PIND as serial input. \\
                   &                & You can use this option only with the software UART. \\
    \hline
    UART\_TX        & UART\_TX=D1   & Specifies the port and bit number used for the serial output. \\
                   &                & The example select bit 1 of PORTD as serial output. \\
                   &                & You can use this option only with the software UART. \\
    \hline
   INVERSE\_UART  & INVERSE\_UART=1 & Inverse the logic level for RX and TX data.\\
	           &                & This option can only used with software UART. \\
    \hline
    UART           & UART=1         & Select a hardware UART used for the serial communication \\
                   &                & You can only select a UART if more than one is present. \\
		   &		    & This option will also change the default setting for SOFT\_UART.\\
    \hline
 LED\_START\_      & LED\_START\_   & Select a repetition count of flashing cycles for the \\
   FLASHES         &   FLASHES=3    & control LED. A count of 1 or -1 will only flash once \\
                   &                & without a loop. Negative values will switch off a \\
                   &                & additional check of the RX pin of the serial interface. \\
                   &                & The loop is interrupted immediately, if any incoming \\
                   &                & serial data is detected. Please note, that the start of \\
                   &                & application program is delayed with the blink cycles. \\

    \hline
 LED               & LED=B3         & Select a port and bit number for the control LED. \\
                   &                & The example would select the bit number 3 of the \\
                   &                & port B for the LED connection. With the option \\
                   &                & LED\_START\_FLASHES  this LED will flash the \\
                   &                & specified count before the communication start. \\
    \hline
 LED\_DATA\_       & LED\_DATA\_    & The control LED will glow during waiting for \\
      FLASH        &    FLASH=1     & serial input data, if the value is 1. \\
	           &                & If you set the variable to 4, the LED ist switch on \\
		   &                & once at the beginning of the bootloader \\
		   &                & So you can also see, that the bootloader has started, \\
		   &                & but this setting to 4 with a zero LED\_START\_FLASHES \\
		   &                & will save a lot of flash memory. \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Important options for the optiboot Makefile}
  \label{tab:options1}
\end{table}

When operating with the internal RC generator, it is quite possible that a serial data transfer
not immediately succeed. This is principle independent of whether the hardware UART interface
or a software solution (SOFT\_UART) is used.
Without additional measurement you can only try with estimated OSCCAL\_CORR values.
Probably the data sheet of the AVR processor can help a little bit.
Here is described at which operating voltage and at what temperature the RC oscillator
was calibrated. 
In addition here is also described the gradient of frequency change with operating voltage,
temperature and OSCCAL modification.

More options are listed in tables~\ref{tab:options2} and~\ref{tab:options3}. 
Some of these options are only interesting for software checks, the frequency adjusting of
the RC-generator and for processors without the boot-loader support.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | l |}
    \hline
   Name of        & Example        & Function                                            \\
   the Option     &                &                                                     \\
    \hline
    \hline
 TIMEOUT\_MS       & TIMEOUT\_MS=2000 & This option specifies a time limit in ms units \\
                   &                  & for receiving boot data. After this time without \\
                   &                  & data the boot process is aborted and the \\
                   &                  & processor tries to start the user program. \\
                   &                  & Possible values for TIMEOUT\_MS are 500, 1000, 2000, \\
                   &                  & 4000 and 8000. The efffective value can be limited \\
                   &                  & to 2s because of processor limits for the watchdog. \\
                   &                  & If no TIMEOUT\_MS is specified, the time limit is \\
                   &                  & set to 1 second. \\
    \hline
    SUPPORT\_      & SUPPORT\_      & Select the EEprom read and write function for the  \\
    EEPROM         &  EEPROM=1      & boot-loader. If the assembly language is selected as \\
                   &                & source, the EEprom support is enabled without  \\
                   &                & this option, but can be switched off by setting \\
                   &                & the SUPPORT\_EEPROM Option to 0. \\
                   &                & For the C-source the function must be switched \\
                   &                & on (default = off). \\
    \hline
 C\_SOURCE         & C\_SOURCE=1    & Select the C language as source instead of the  \\
                   &                & assembly language (option 0 = assembly).\\
                   &                & The assembly version requires less program space. \\
    \hline
    \end{tabular}
  \end{center}
  \caption{More options for the optiboot Makefile}
  \label{tab:options2}
\end{table}

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | l |}
    \hline
   Name of        & Example        & Function                                            \\
   the Option     &                &                                                     \\
    \hline
    \hline
 BIGBOOT           & BIGBOOT=512    & Select additional space usage for the compiled \\
                   &                & program. This is used only for tests of the \\
                   &                & automatic adaption to the program size. \\
    \hline
VIRTUAL\_          & VIRTUAL\_       & Changes the interrupt vector table of a user program, \\
 BOOT\_            & BOOT\_          & that the boot-loader is called with a Reset. \\
 PARTITION         & PARTITION       & For the start of the user program another \\
		   &                 & interrupt vector is used.          \\
    \hline
 save\_vect\_      & save\_vect\_    & Choose a interrupt vector number for the  \\
      num          &    num=4        & VIRTUAL\_BOOT\_PARTITION method.        \\
    \hline
 OSCCAL\_          & OSCCAL\_       & With the option OSCCAL\_CORR you can adjust the \\
 CORR              & CORR=5         & internal 8~MHz RC-generator of the AVR. \\
                   &                & Is effectless with crystal-operation or external clock! \\
                   &                & The correction value will be subtracted from the actual \\
                   &                & OSCCAL byte. The frequency will be lower with a positive \\
                   &                & correction value. Because the produced Baud rate is \\
                   &                & directly derived from the processor clock, a correct \\
                   &                & selected processor clock is important for a successful \\
                   &                & serial communication. The value must be between -15 and +15. \\
    \hline
 NO\_EARLY\_       &  NO\_EARLY\_   & Prevents the erasing of the flash page before the data \\
 PAGE\_ERASE       & PAGE\_ERASE=1  & is received via the serial interface. \\
                   &                & Programming the flash with this option is about 30\% slower, \\
                   &                & because the deletion otherwise runs parallel to the \\
		   &                & data reception. But the time loss is not so significant, \\
                   &                & because the also carried out data verification takes about \\
		   &                & the same time and is uneffected. This saves about 14 bytes \\
		   &                & of space on the bootloader side of the optiboot, which \\
		   &                & in practice can also mean that the space requirement  \\
		   &                & can be halved due to the AVR technology. \\
    \hline
    \end{tabular}
  \end{center}
  \caption{More options for the optiboot Makefile}
  \label{tab:options3}
\end{table}

\section{Usage of optiboot without a boot-loader area}

For processors without a special boot-loader area in the flash memory, for example the ATtiny84,
a solution is selectable to use the optiboot anyway.
This function can be selected with the VIRTUAL\_BOOT\_PARTITION option.
To start the boot-loader first with every Reset of the processor, the interrupt
vector table of the application program is changed.
At the reset vector location a jump to the optiboot program is registered.
The original start address of the application program will be moved to
another interrupt vector the ''replacement reset vector''.
This interrupt vector should not be used by the application program.
If the boot-loader does not receive any data from the serial interface within
a appropriate time, the boot-loader jump to the location of the replacement
reset vector and start the application program.
The figure~\ref{fig:VectorMove} should illustrate these changes.

\begin{figure}[H]
\centering
\includegraphics[]{../FIG/VectorMove.eps}
\caption{Changes of program data by optiboot}
\label{fig:VectorMove}
\end{figure}

At the left side the content of the program data file (.hex) is shown.
Just to the right the content of the flash memory is shown, as it is modified by the
optiboot boot-loader. At two interrupt vector addresses the content is changed.
At the reset vector address 0 the jump is modified to select the optiboot start address 
as jump target.
At the ''replacement vector address'' 4 the original jump target address of the application
program's reset vector is used as new jump target address of this vector.
One of the problems with this modification is, that usually the program data
is verified by the host after write is finished.
To provide any error message by verify the program data, the optiboot return the
program data without its own modification, not the real content of the interrupt vector table.
The jump target address of the reset vector can be reconstructed with the content
of the replacement vector address.
But the original content of the replacement vector would be lost because there is no
place to save the original content in the flash memory.
Therefore optiboot use the last two places of the EEprom memory to save this original
content of the replacement vector. 
So the verify of the program data is possible without errors, as long as the application
program do not use one of the last two EEprom locations.
Even if the application program use one of the last two EEprom locations,
the boot-loader will be unaffected. Only the program verify by the host is
no longer possible without a error message.
An error message will occur at the location of the replacement interrupt vector.

For processors with more than 8 kByte flash memory two instruction words are used for every
interrupt vector. Normally every of this double words hold one JMP instruction with the
proper jump target address. The optiboot program can respect these JMP vector table too.
But if you use the linker avr-ld with the option --relax, all JMP instructions are replaced
by a RJMP, if this is possible for the target address.
This replacement of JMP instruction in the vector table by RJMP is not respected
by the optiboot program.
The optiboot program assume, that all interrupt vector numbers of a processor with
more than 8 kByte flash hold a JMP instruction.
For that reason a optiboot program with the VIRTUAL\_BOOT\_Partition option will not
work with a application program, which is linked with the --relax option.
The same problem exist, if the application program itself use a RJMP instruction in
one of the two critical interrupt vector positions.

Further you should notice, that you don't activate the BOOTRST fuse together with
with the usage of the VIRTUAL\_BOOT\_PARTITION option.
The reason is, that the start address of the boot-loader can be located to other
addresses with the VIRTUAL\_BOOT\_PARTITION option than without this option.
With the VIRTUAL\_BOOT\_PARTITION the start address can be placed to every
begin of a flash page. For the normal boot-loader support of the AVR the
start address can only respect the single, double, quadruple or octuple size of
a minimum boot-loader size as shown in figure~\ref{fig:pages} at page~\pageref{fig:pages}.


\section{Capabilities of the serial interface with the applied software}

Das Programm f√ºr die Erzeugung und Verarbeitung der elektrischen Signale ist in AVR-Assembler geschrieben.
The way of operation is taked over from the Application Note AVR305 of the ATmel Corporation.
However here are some special features build in.
For example it is respected, that we can not use the special bit-instructions SBI, CBI and SBIC for
any port address. You can use this instructions only up to the address 31 (0x1f).
For some higher port addresses up to 63 (0x3f) you can use special input (IN) and output (OUT)
instructions. If the addresses of the port are higher than this value, you must use
the instructions LDS and STS to access this ports. This instructions need 2 processor clocks for
execution and use the double flash memory (2 words or 4 byte) of the other instructions.
The changed cycle number of one loop pass without any additional delay will be automatically
determined by the program. 
This number of cycles is then taken into account for the calculation of the delay loop,
to achieve a correct time for the transmission of a bit.
The diagrams~\ref{fig:getch_timing} and~\ref{fig:putch_timing} should be used to
explain the work of the C-proprocessor.

\begin{figure}[H]
\centering
\scalebox{0.9}{\includegraphics[]{../FIG/uart_getch_timing.eps}}
\caption{Possible variants of the getch function}
\label{fig:getch_timing}
\end{figure}


\begin{figure}[H]
\centering
\includegraphics[]{../FIG/uart_putch_timing.eps}
\caption{Possible variants of the putch function}
\label{fig:putch_timing}
\end{figure}

Both loops are generated so that one cycle with the same conditions of INVERSE\_UART option and
address range of the used ports use the same tic count.
So both functions can use the same function for generating the necessary delay.

\subsection{Computing of the delay time}
For the read-in function getch() is the half baud time needed.
From the detection of the start bit a total time of 1.5 times of the baud-time is delayed
to read the first data bit.
Therefore the base loop is designed for the half duration of a bit transmission.
This base loop is called twice in a special way, so that exactly twice the time is get.
Should one clock have been lost by the building of half the time and subsequent doubling,
this clock is compensated by adding a additional NOP command, so that the total time
is exactly correct for the transmission of one bit.
Because of the limited time resolution of the counter loop of 3 tics, a remainder of up to 2 clock tics
is compensated by adding a additional instruction with the right tic count (RJMP or NOP).
Of course, all this happens automatically, because only the loop time of the input function (getch)
and the output function (putch), the clock frequency of the processor and the desired baud rate
must be known. All other parameters like the number of clocks for a subroutine call (RCALL, RET)
are known for the traget processor.
A disadvantage of the base delay loop is the limited number of clocks for the delay.
With the used 8-bit counter only a maximum of 256*3 clocks is possible for the loop delay.
In addition there is the subroutine call of 7 tics, resulting in a half delay time of 775 tics.
This value must be doubled (delay for a whole bit time) and the loop-time of the input or output
function must be added to get the total time possible. Thus the highest achievable delay time is 1559 clocks.
With a \(16 MHz\) clock frequency you can not get a baud rate of 9600 Baud \(104.17\mu s\), because
the limit is only \(97.4\mu s\).
If a 16-bit counter is used by the delay loop, you would get an even worse resolution of time
because one loop cycle would take more time.
In addition, the 16-bit loop probably need to use the carry bit. The 8-bit counter don't use the carry bit.
This problem is solved by gradually doubling the delay times by doubling the delay loop call.
The C-prepocessor checks, if the initial value of the loop counter would match the 8-bit limit (255) at the
selected clock frequency and the desired baud rate.
In this cace the calculation is repeated for a double call of the base delay loop.
If the resulting initial value for the counting loop is still too high, the double call is doubled again.
Currently this procedure is repeated up to a factor 64 of the base time with the 8-bit counter.
At a clock frequency of \(16 MHz\) or \(20 MHz\) it is now possible to set the serial interface to 300 baud.
For every doubling of the delay time, a additional instruction (2 bytes) is required.
With the maximum count of doubling 6 additional instructions (12 byte) are required in the flash memory.
There is no attempt to add additional instructions to compensate the missing tics caused by
the prescaler for saving flash memory.
The baud time error remains clearly below \(1\%\), because the scaler is used only if necessary.
So the base loop has at least 127 passes with approximately 381 tics, The double delay time
makes no error because of the ''NOP'' compensation. Thus the error stays below 1:762 \(0.13\%\). 
The higher baud rates tend to get higher error for the transmission time, because
the time frame of the CPU clock does not match to the desired baud time.
The hardware UART has then the same problem, if it use the same CPU-clock.
If you wish to generate a baud rate of 230400 with a CPU clock rate of \(16 MHz\),
your UART can operate with \(2 MHz\) in the best case.
So you can use either 8 tics with a baud time of \(4\mu s\) or
9 tics with a baud time of \(4.5\mu s\).
For the first case your baud time is \(7.84\%\) too short, for the
second case the baud time is \(3.68\%\) too long.

\subsection{Using more than one serial interface}

The assembler file soft\_uart.S is designed to be included by a different file which hold
a normal assembler source for the AVR family.
For the optiboot application this is done by the optiboot.S file.
The included file soft\_uart.S use many instructions of the
GNU C-preprocessor and includes another file uart\_delay.S for producing a delay loop
for the desired baud rate. Because this include can be repeated with other parameters,
you can produce up to 4 different delay loops for 4 different baud rates.
This feature use the file soft\_uart.S for generatung a getch and a putch function.
For both functions the file uart\_delay.S is included. But for the second call is
usually no new code generated because the calling parameters are the same.
Only if the parameters differ, a new delay loop would be generated.
Please note, that the callings for the delay loop are named with C-preprocessor macros.
This macros are set to a matching delay loop named DOUBLE\_DELAY\_CALL and SINGLE\_DELAY\_CALL,
if you include the uart\_delay.S file before the code of the serial input or output function.

Three constants must be set before any include of uart\_delay.S, named F\_CPU, BAUD\_RATE and 
LOOP\_TICS. The LOOP\_TICS must be set to the count of tics of the serial input or output
loop for one cycle without any additional delay (usually 9 tics).
For every generated delay loop, the total count of delay tics are saved in one of four
different constant names of the C-preprocessor BIT\_CLOCKS\_0, BIT\_CLOCKS\_1,
BIT\_CLOCKS\_2 and BIT\_CLOCKS\_3 . 
Before a new delay loop is generated, the C-preprocessor checks, if any of the already
generated code for a delay match the new requirement.
Because also the file soft\_uart.S must be included to generate the code for the 
serial input and serial output function, you can repeat this include for another
serial interface. But you must set a additional constant for differing the name
in the functions.
If you set the SOFT\_UART\_NUMBER to 1 (\#define SOFT\_UART\_NUMBER 1) before the \#include,
the serial input function is named getch\_1 and the serial output function
is named putch\_1. If you define a constant named NO\_SOFT\_UART\_TX before the
\#include of soft\_uart.S, no serial output function is generated by this include.
The same is done with the serial input function, if you specify the constant NO\_SOFT\_UART\_RX.

\subsection{Serial Input and Output with only one AVR Pin}

Sometimes it makes sense to operate the serial communication only with one pin,
to unlock one of the few IO pins of small AVRs for other use.
With a special circuit technology can be achieved that you can read in data in the
output pauses. The software solution of optiboot can only use the half-duplex operation
in any case.
Thus, at one time, only either data can be send or data can be received.
Normally the output pin with the TX function becomes high in the transmission pauses,
which prevent a data reading on the same pin.
But if the TX output pin is switched to input mode instead of the high level,
a external pull-up resistor can provide the required high level.
In contrast to the fixed high level now a externally connected TX signal
can pull down the level and let the input function read the low level.
A serial resistor in the connection between the common TX/RX pin of the AVR
with the external TX output can serve as pull-up resistor,
because the idle state if the interface is a high signal.
In addition, this serial resistor provides current limiting,
if both TX interfaces send at the same time.
The external RX interface must be connected directly to the common TX/RX pin
to enable the reading of the external RX interface.
The figure~\ref{fig:onewire-simple} should illustrate this simplest connection.

\begin{figure}[H]
\centering
\scalebox{1.0}{\includegraphics[]{../FIG/OneWire_simple.eps}}
\caption{Possible serialconnection to a AVR with one Pin}
\label{fig:onewire-simple}
\end{figure}

Now is the problem, that the mostly full-duplex capable external interface will
read back the own output.
The communication program like avrdude at the external side is usually unprepared for this condition.
One solution for this problem is to adapt the program at the external side to handle
this read back.
But I believe, that this is not a good idea, because this special version will 
have no maintenance or you must repeat this adaption for new versions constantly.
That's why I prefere a hardware solution.
A electronic circuit between the both endpoints must differ, from which side
the data are send.
A corresponding circuit suggestion is shown in figure~\ref{fig:onewire}

\begin{figure}[H]
\centering
\scalebox{0.5}{\includegraphics[]{../FIG/OneWire.eps}}
\caption{Circuit for suppressing the echoes}
\label{fig:onewire}
\end{figure}

With the first two NAND gates of the HCF4093 a flip-flop is build,
which is set or reset by the two other NAND gates of this chip.
The switching signals are get from from signals of a chain of inverting buffers
with Schmitt-trigger inputs (HC7414).
For one of this signals a additional C-R circuit (\(120 pF\) and \(3.3 k\Omega\) is
required to prevent switching at the wrong edge.
The flip-flop is switched with the 1-0 edge of the two transmission sides.
This changeover is only required at the edge of the start bit.
But additional switching with data bits will not hurt, if the flip-flop
is already in the right state.
When the external interface sends, the reception of the own data with the
external receiver is prevented. The external RX signal remains at high level.
With this additional circuit no software adaption is necessary.
You can use avrdude for example for the bootloader.
The circuit is largely independent of the selected baud rate.
I expect only problems with very high baud rates.
At 115200 baud the circuit operates well. Much higher baud rates can 
not be used in most cases with the software serial interface.

\subsection{Use of the automatic baud rate detection}
\label{sec:autobaud}

If you specify a baud rate below \(100Baud\) for generating the bootloader code,
the program will be prepared to detect the baud rate from the first
received character.
At the begin if the transmission with the STK500 protocol the computer send
a command STK\_GET\_SYNC (0x30) followed by the control character CRC\_EOP (0x20).
For the serial transmission protocol the High level (1) is defined as the idle state.
The begin of a transmission is started by s start bit with Low level (0).
Directly after the end of the start bit the first data bit is send 
beginning with the low order bit. After the last of the aggreed count of bits (8)
is transmitted, the transmission is finished with one or more Stop bits at High level (1).
The level of every bit is hold exactly the aggreed baud time.
The time between the end of the last Stop bit and the begin of the next Start bit
is unspecified.
The figure~\ref{fig:AutoBaud} shows the expected results for all possible
time measurement. At the time axis ''t'' four possible start positions
are marked for a complete time measurement of the assumed character.
The counter is started in each case of a detected 1-0 slope.
The right start position for the STK\_GET\_SYNC character is marked with ''1''.
The marks ''2'', ''3'' and ''4'' show the situation for three possible
wrong Start bit detections.
For the mark ''2'' and ''4'' a 1-0 slope of data bits is detected as Start bit
in a wrong way. For the mark '3' is a Start bit correctly detected, but for the
wrong character (CRC\_EOP).
The wrong detections are allways possible, if the bootloader is started not
before the transmission was running.
The expected counter values are marked at the counter level graph for all
four start positions in figure~\ref{fig:AutoBaud}. 
The ''b'' means the counter reading for one bit transmission time (baud time),
the ''d'' stand for a possible time delay between the end of the Stop bit transfer 
and the start of a new Start bit.
The ''D'' represents a expected long time delay to the begin of the next message.
The transmit sequence of the message has reached it's end and the computer
wait for an answer of the AVR.
In the ''Rx''-row the data bits are labled with ''0'' (least significant bit)
to ''7'' (highest significant bit). The Start bit has the label 'A' and
a Stop bit has the label 'E'.
The first byte is the coding of the STK\_GET\_SYNC character and the second byte
is the coding of the control character CRC\_EOP.

\begin{figure}[H]
\centering
\scalebox{0.55}{\includegraphics[]{../FIG/AutoBaud.eps}}
\caption{Possibel timer measurements for the STK\_GET\_SYNC sequence}
\label{fig:AutoBaud}
\end{figure}

\begin{itemize}

\item {Simplest way of baud rate measurement, BAUD\_RATE \textless~30}

The simplest form of baud rate measurement doesn't take into account
the wrong start bit choise.
It is assumed, that the detected Start bit belongs to the STK\_GET\_SYNC
character.
After the Start bit detection the program waits to the next 0-1 slope
and starts a 16-bit counter with the frequency F\_CPU/8 with the
stating value -1. At the next 1-0 slope the counter value is read out
and the half of this value is taken as frequency divider for the UART.
The building of the half value is required because the time of two data bits (4-5)
was measured.
Normally 1 must be subtracted for the UART frequency divider.
But when halving should be rounded, a 1 must be added before the halving.
Because also 2 can be subtracted from the counter result instead of
1 from the division result, totally only one must be subtracted from the
counter result. In order to save computation steps, the subtraction (2-1=1)
from the count is done by a start value of the counter of -1.

This method works well, if the bootloader is started automatically just
before the transmission by generating a reset pulse from the DTR (Data Terminal Ready)
signal of the serial interface.
You can also be successfull without the automatically generated Reset,
if a Reset key is connected to the AVR, which should be hold pressed
until the transmission program is started.
But this procedure requires some feeling for the right release time
of the button.

The bootloader only waits a maximum time for the beginning of the transmission,
which is specified from the watchdog timer.
When the watchdog timer triggers a reset, usually the user program is started.
Only if no user program has been loaded yet, the boot loader starts again for a retry.

\item {Improved way of baud rate measurement, BAUD\_RATE \textless~40}

Same as the simple way of baud rate measurement this method does not
check the correctness of the bit change sequence.
But the software wait for the next 0-1 slope until the counter value
is read.
		So this counter reading is the time of four data bits (4-7),
which is then used for the baud rate determination.
Because the time recording is slightly inexact because of the
polling loop, the baud time result will be better with dividing by four
than by dividing by two.
For that reason this method should be prefered, if little flash memory
use is important. This improved method use only 4 byte more than the
simple way.

\item {Simplest way of baud rate measurement with time limit, BAUD\_RATE \textless~50}

The same method as the simplest way is used for this method.
Only a additional limitation for the timer value is used here.
If the time limit is passed over, the program starts again with the search
for a new Start bit.
Without this limitation the program can stay in a loop for detecting
a low level for the start condition ''4''. 
Probably the bad situation with the start position ''4'' in the 
diagram~\ref{fig:AutoBaud} can be handled a little better. 
The restart of the start bit search with the time limit would
delay a reset from the watchdog timer only a little bit.
The bootloader program may not reset the watchdog timer inside
the search loop, because then the user program is never started
without the transmission of a new program.
For this reason the time limit of the watchdog timer must be greater
as the time delay for repeating the STK\_GET\_SYNC sequence
without a answer to the previous STK\_GET\_SYNC sequence.

\item {Improved way of baud rate measurement with time limit, BAUD\_RATE \textless~60}

The baud rate measuring is done in the same way as described for the
improved way (\textless 40).
Simular to the method ''\textless 50'' the wait time for the 1-0 slope
is limited to the overflow of the 16-bit counter.
But because the counter value is normally read at the next 0-1 slope,
the result is equal to the improved way without the time limit.


\item {Complex way of baud rate measurement, BAUD\_RATE \textless~80}

With this method the counter is started immediately with the detection
of a Start bit and the counter value is read with every of the
next 3 bit changes.
The time sequence of bit changes for the STK\_GET\_SYNC character is 
measured with this method, if the start position is well (''1'').
With this measured time sequence some plausibility checks are done.
For a first is checked, that the difference between the third counter
reading and the first counter reading is less than the value
of the first reading.
For the start position ''1'' this is the case ((9b~-~5b) < 5b).
For the wrong start position ''3'' this is unfortunately also the case ((9b~-~6b) < 6b)
But this test will fail for start condition ''2'', if the time delay ''d'' of
the second start bit of the STK\_GET\_SYNC sequence is sufficiently small.
For the wrong start position ''4'' can help only a time limitation for
the second bit change wait loop, because the repetition of the STK\_GET\_SYNC
is done after a longer wait time for the answer (''D''). 

A second test checks, if the difference between the third and the
second counter reading isn't significant greater than the difference
between the second and the first counter reading.
For the correct start posistion ''1'' this result to the equation ((9b-7b) < (7b-5b+4))
or (2b < 2b+4).
For the false start position ''2'' you get the equation ((9b-3b) < (3b+d-2b+4)) or
(6b < (b+d+4)).
For the false start position ''3'' we get the equation ((9b-7b) < (7b-6b+4)) or (2b < (b+4)).
This exams are relatively safe for detecting the right baud rate, but they
require a lot of additional space for the program.
This method is especially recommended, if at least 1024 bytes are reserved
for the boot loader anyway (boot loader page size).
For setting the correct UART frequency divider, the difference between 
the third counter reading and the second counter reading is divided by 2
(9b-7b-1)/2 = (2b+1)/2-1.

\item {Aufwendige Form der Baudraten Messung, BAUD\_RATE \textless~100}

All counter readings and checks are done in the same way as the
BAUD\_RATE \textless~80 method. Only the calculation of
the UART divider is based on the time of four bits instead of two bits.
Consequently the equation for the correct starting position
look like (9b-5b-2)/4 = (4b+2//4-1.

\end{itemize}

I recommend for all methods of the baud rate determination to omit
the LED flashing at the begin of the bootloader program
to prevent a delay of the start bit detection.
Unfortunately even the simplest way of baud rate measurement
need so much additional program memory, that the bootloader
will not fit into the 512 byte limit, if the EEprom support
is selected (SUPPORT\_EEPROM=1) with the flashing LED function.
For some processors you can select the additional function LED\_DATA\_FLASH
without exceeding the 512 byte limit, when the EEprom support is deselected.
If the 512 byte limit is overshoot by a required function,
the next limit of 1024 byte give enough space for all additional
selections.
You can select the SOFT\_UART function together with the automatic
baud rate detection (BAUD\_RATE \textless 100) only for the
assembler version of optiboot, not for the C-version.

The following table~ref{tab:AutoBaudControl} summarize the different options.
The specified program sizes in bytes refer to an ATmega328 without LED flashing function,
but with the EEprom support.
The program sizes in brackets result from the operation of the serial interface with software.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | c | c | c | c |}
    \hline
    BAUD\_RATE  & Bit   & Clock  & Time  & Check & mega328\\
		& Base  & Base   & Limit &       & size (HW) \\
    \hline
    \hline
	    10-14      &  9     & clk/8 &   -    & simple  & 500  \\
    \hline
	    15-19      &  9     &  clk  &   -    & simple  & 502  \\
    \hline
	    20-24      &  2     & clk/8 &   -    & simple  & 488  \\
    \hline
	    25-29      &  2     &  clk  &   -    & simple  & 494  \\
    \hline
	    30-34      &  4     & clk/8 &   -    & simple  & 492  \\
    \hline
	    35-39      &  4     &  clk  &   -    & simple  & 494  \\
    \hline
	    40-44      &  2     & clk/8 &   Yes  & simple  & 494  \\
    \hline
	    45-49      &  2     &  clk  &   Yes  & simple  & 500  \\
    \hline
	    50-54      &  4     & clk/8 &   Yes  & simple  & 498  \\
    \hline
	    55-59      &  4     &  clk  &   Yes  & simple  & 500  \\
    \hline
    \hline
	    60-64      &  2     &  clk/8 &  Yes  & complex & 544  \\
    \hline
	    65-69      &  2     &  clk   &  Yes  & complex & 550  \\
    \hline
	    70-74      &  4     &  clk/8 &  Yes  & complex & 548  \\
    \hline
	    75-79      &  4     &  clk   &  Yes  & complex & 550  \\
    \hline
	    80-84      &  9     &  clk/8 &  Yes  & complex & 558  \\
	    90-94      &        &        &       &         &      \\
    \hline
	    85-89      &  9     &  clk   &  Yes  & complex & 560  \\
	    95-99      &        &        &       &         &     \\

    \hline
    \end{tabular}
  \end{center}
  \caption{Setting options for the baud rate measurement.}
  \label{tab:AutoBaudControl}
\end{table}


There are some differencies and special features for the baud rate measuring
together with the Soft UART solution compared to the hardware UART solution.
Usually a 8-Bit counter loop is used to generate the delay for the half baud time.
Because of the used instructions in this loop, you can select the time
only with a solution of 3 clock tics.
To get the full baud time the loop must be called twice, so that
the resolution is doubled too.
With a known fixed baud rate this error will be compensated by extra instructions.
But this is impossible, if the baud rate  is unknown in advance.
To get the best possible rounding of the selected baud rate,
the time measurement should be done with the 16-bit counter at the full CPU clock rate (F\_CPU).
For the hardware UART the counter can be used with F\_CPU/8, because the UART
use a identical clock rate and the time is measured for 2 or 4 bits.

The use of a 8-bit delay loop result to a upper limit of the baud time
depending on the CPU clock rate.
The resulting minumum baud rate is definite higher with the 8-bit loop
compared to the minimum baud rate with the hardware UART.
With the limited resolution of the period selection for the baud rate
the upper limit can be specified with a guaranteed baud rate error below 2\%.
If the AVR processor is operated with a RC clock generator, the clock rate
is usually imprecise. By measuring the baud rate with a counter controlled
with the same clock, this error is compensated.
But the error by reason of the limited resolution of the baud rate divider 
can not be calculated in advance.
I would like to show you what I mean by an example for the hardware UART. 
The baud rate \(250kHz\) can be used with a clockrate of exactly \(8MHz\).
If you select the divider of 4, the desired baud rate is together with
the factor 8 prescaler produced without a deviation.
If I assume a inexact real clock rate of \(7.6MHz\),
the best selectable divider is still 4.
For this case the actual baud rate is now \(237.5kHz\) with the same
error of -5\% as the base clock rate.
To overcome at least the lower baud limit with the software UART solution,
all baud rate selections between 20 and 99, which are odd-numbered,
will generate a code with a 15-bit delay loop.
Unfortunately the pass time of this loop is 5 tics for the 15-bit loop.
Because of the double delay call for the full baud time,
the resolution is only 10 tics and thereby more worth than the 
8 tics resolution of the hardware UART caused by the 8:1 prescaler.
You should use this option only, if you need the support of low baud speeds
and deside not to use very high baud rates.
The following table~\ref{tab:AutoBaud8} is intended to clarify the use of
the different auto baud functions at the operating frequency \(8MHz\).
The table does not respect the time error, which can be caused by the
polling loops for the RX signal.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | c | c | c | c |}
    \hline
   BAUD\_RATE  & SOFT\_ & Minimum   & BAUD-Err & Comment  \\
   Option      & UART   & Baud      & \textless 4\% @ Baud &  \\
    \hline
    \hline
  10-14,20-34  &  0     &  244      &   80.0k  & HW\_UART 2-Bit Time  \\
  40-54,60-64  &        &           &          & or CLK/8 measurement    \\
  70-74,80-84  &        &           &          &                         \\
    \hline
  35-39,55-59  &  0     &  488      &   80.0k  & HW\_UART 4-Bit Time, CLK  \\
    \hline
  15-19,65-69  &  0     &  1098     &   80.0k  & HW\_UART 9-Bit Time, CLK  \\
  75-79,85-89  &        &           &          &                         \\
    \hline
    42         &  1     &  5151     &   81.6k  &  Simple, 2-Bit Time, 8-Bit Loop  \\
    \hline
    62         &  1     &  5151     &   81.6k  & Complex, 2-Bit Time, 8-Bit Loop  \\
    \hline
    72         &  1     &  5151     &   81.6k  & Complex, 4-Bit Time, 8-Bit Loop  \\
    \hline
    47         &  1     &  244      &   53.3k  &  Simple, 2-Bit Time, 15-Bit Loop \\
    \hline
    67         &  1     &  1220     &   53.3k  & Complex, 2-Bit Time, 15-Bit Loop \\
    \hline
    77         &  1     &  1220     &   53.3k  & Complex, 4-Bit Time, 15-Bit Loop \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Limits for the automatic baud rate selection with a \(8MHz\) clock.}
  \label{tab:AutoBaud8}
\end{table}

Usually a limit for the baud error is set to only 2\%, because the transmitter and
the receiver can have a baud rate error to the opposite direction.
The Auto-baud function measure the actual baud rate of the transmitter,
so that the error rate of the Auto-baud function can take the double value of 4\%.
If you select a hardware UART interface, you can select the standard
baud rates 1200, 2400, 4800, 9600, 19200 and 38400 with all arbitrary options.
Higher baud rates than the specified 40 kBaud are not safe to use,
although 57600 baud also worked well in tests.
Likewise, a test with 115.2 kBaud at \(16MHz\) crystal operation was still successful
when using a software UART with a 15-bit delay loop.
If only a 8-bit delay loop is used with the software UART solution,
the baud rates 1200, 2400 and 4800 can not be used.
The lower baud rates are only usable with the software UART, if you configures
the optiboot with a 15-bit delay loop.
The different limit for the 49 and 69 or 89 baud rate selection is caused
by the different use of the 16-bit AVR counter.
With the 49 selection (all below 60) only the time of two data bits is measured
with the counter. For selections above 59 the complete byte sequence is
measured from the Start bit to the Stop bit with the 16-bit counter.
Probably baud rated below 9600 are rarely used anyway.
Of course the limits of the baud rates change with other processor clock rate.

There are numerous setting options for the UART interface software, which on the
one hand relate to the measurement base of the baud time, but also relate to the type
of delay calculation.
In the table~\ref{tab:AutoBaudLen328} the program lengthes of the bootloade are shown
for a ATmega328 target processor.
Unfortunately the programs in the colums labled with \_0 and \_5, this means all
Baud rate selections ending with the digit 0 or 5, are practical unusable.
The reason herefore is, that the division operation by successive subtraction
is too slow to finish before the serial data stop bit ends.
A workaround would be to let the transmitter of the data (avrdude) send all data with 2 stop bits.
Because this is not intended, the other columns use an accelerated subtraction loop,
which then causes a longer program.
If possible, the faster shift operation for division by powers of 2 is used instead of the subtraction loop.
To enable this shift operations, the colums labled with \_3, \_4, \_8 and \_9 
has increased the number of cycles for one delay loop pass (8T or 16T, T for tics).
Unfortunately the program length is only shorter compared to the subtraction loop,
if the count of shift operation is below 3, which would spare the loop operation for the shifts.
But you can save 14 bytes of flash with the option NO\_EARLY\_PAGE\_ERASE , so that about
30 versions more match to a 512 byte limit.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | c| c | c | c || c | c | c | c | c |}
    \hline
    BAUD\_RATE  &  \_0 & \_1   &  \_2 & \_3   & \_4    &  \_5  &  \_6  &   \_7 &  \_8   &  \_9 \\
    ,Measurement base   & 6T/8T &  10T &  6T  &  16T  &  8T    &  10T  &  6T   &  10T  &   8T   &  16T \\
    \hline
       & \multicolumn{5}{c ||}{ simple CLK/8}    &  \multicolumn{5}{c |}{simple CLK/1}      \\
    \hline
   1\_ , 9Bit   & 510  & 524   & 516  & 528   & 516    &  522  &  518  &  528  &  520   &  532 \\
   2\_ , 2Bit   & 512  & 528  & 518 & 520 & \textbf{506} & 518 & 514 & 524 & \textbf{512} & 522 \\
   3\_ , 4Bit   & 508  & 524  & 514 & 522 & \textbf{510} & 520 &  516  &  528  &  514   & 532 \\
   4\_ , 2Bit   & 518  & 534  & 524 & 526 & \textbf{512} & 524 &  520  &  530  &  518   & 528 \\
   5\_ , 4Bit   & 514  & 530   & 520  & 528   & 516    &  526  &  522  &  534  &  520   &  538 \\
    \hline
      & \multicolumn{5}{c ||}{ komplex CLK/8}    &  \multicolumn{5}{c |}{komplex CLK/1}      \\
    \hline
   6\_ , 2Bit   & 572  & 588   & 578  & 580   & 576    &  578  &  574  &  584  &  572   &  582 \\
   7\_ , 4Bit   & 570  & 586   & 576  & 590   & 578    &  580  &  576  &  588  &  580   &  592 \\
   8\_ , 9Bit   & 572  & 586   & 578  & 590   & 578    &  584  &  580  &  590  &  582   &  594 \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Bootloader program length with automatic Baud rate selection for Software UART}
  \label{tab:AutoBaudLen328}
\end{table}


Finally I would like to show the results from tests, which I have done with
a ATmega1281 with the internal \(8MHz\) RC-generator clock at a specified baud rate
and also above the specified baud rate.
The frequency was tuned with the OSCCAL\_CORR option in steps of two and
of course measured.
The functionality was tested by loading a small user program.
All tests within the specified baud rate was successfull.
Because all tests run well, additionally tests with a higher baud rate than
specified (\(115.2 kBaud\)) was also done.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c || c | c | c || c |  c | c |}
    \hline
  OSCCAL  & Freq.    & HW-UART & SW-UART & HW-UART & \multicolumn{2}{c |}{SW-UART} \\
   \_CORR  & MHz       & 57600   & 57600  & 115200  & \multicolumn{2}{c |}{115200} \\
           &           & Mode 82 & Mode 82 & Mode 56 & Mode 52 & Mode 57 \\
    \hline
    \hline
    20     &  7.18   &  OK       &   OK    &  Err    &  Err    &   Err \\
    18     &  7.22   &  OK       &   OK    &  Err    &  Err    &   Err \\
    \hline
    16     &  7.35   &  OK       &   OK    &  OK     &  OK     &   Err \\
    14     &  7.45   &  OK       &   OK    &  OK     &  OK     &   OK  \\
    \hline
    12     &  7.56   &  OK       &   OK    &  OK     &  OK     &   OK  \\
    10     &  7.63   &  OK       &   OK    &  OK     &  OK     &   OK  \\
    \hline
     8     &  7.75   &  OK       &   OK    &  OK     &  OK     &   OK  \\
     6     &  7.84   &  OK       &   OK    &  Err    &  OK     &   Err \\
    \hline
     4     &  7.98   &  OK       &   OK    &  Err    &  Err    &   Err \\
     2     &  8.04   &  OK       &   OK    &  Err    &  OK     &   Err \\
    \hline
     0     &  8.18   &  OK       &   OK    &  OK     &  OK     &   Err \\
    -2     &  8.29   &  OK       &   OK    &  OK     &  OK     &   Err \\
    \hline
    -4     &  8.42   &  OK       &   OK    &  OK     &  OK     &   Err \\
    -6     &  8.51   &  OK       &   OK    &  OK     &  OK     &   OK  \\
    \hline
    -8     &  8.64   &  OK       &   OK    &  OK     &  Err    &   OK  \\
    -10    &  8.77   &  OK       &   OK    &  OK     &  OK     &   OK  \\
    -12    &  8.92   &  OK       &   OK    &  Err    &  OK     &   OK  \\

    \hline
    \end{tabular}
  \end{center}
  \caption{Test for the automatic baud rate at \(8MHz\) clock.}
  \label{tab:AutoBaudTest8}
\end{table}

For the operating mode 82 I have additionally checked the odd OSCCAL\_CORR settings without
any noticeable difficulties. The also checked simplest mode 42 has not shown
any difficulties with the tested even OSCCAL\_CORR values of the table.

Only at the extemely high baud rate of \(115,2k\) for this CPU frequency the operation
mode 52 shows four failures and with the operation mode 57 eight failures are stated.
The increase in failures in mode 57 with the 15-bit delay loop is expected and caused by
the coarser grid of adjustable delay times.

A test with a chinese Arduino UNO board, which use a CH340G chip as USB-serial converter,
could operate only up to \(38.4kBaud\) correctly.
With higher baud rates the read back of the flash data caused problems.
Probably the last byte of a package is sometimes not transmitted to the host and
the communication blocks.
The same test with a other Arduino UNO board, which use a Mega16U2 controller
for USB-serial conversion, didn't show the same problem.
This board could run with \(115.2kBaud\) and also with \(230.4kBaud\). 
Probably the reason is, that both processors (ATmega328p and Mega16U2)
use a real baud rate of \(250kBaud\).


\section{Some examples of building a optiboot bootloader}

The first example is the building of a bootloader for the popular ATmega328P:

\begin{verbatim}
optiboot $ make atmega328p

Optiboot for 16000000 Hz (16.00 Mhz) operation with Baudrate 115200 and EEprom \
  support configured.
 >>> Start building for AVR atmega328p:
LED-Pin PB5 use Pin 19-PDIP28 17-TQFP32, with special functions: SCK PCINT5
RX-Pin PD0 use Pin 2-PDIP28 30-TQFP32, with special functions: PCINT16 RXD
TX-Pin PD1 use Pin 3-PDIP28 31-TQFP32, with special functions: PCINT17 TXD
avr-gcc -g -Wall -Os -fno-split-wide-types -mrelax -mmcu=atmega328p \
 -fno-diagnostics-show-caret -DBAUD_RATE=115200 -DLED_START_FLASHES=3 \
 -DSUPPORT_EEPROM=1 -DLED=pB5 -DUART=00 -DSOFT_UART=0 -DUART_RX=pD0 -DUART_TX=pD1 \
 -DF_CPU=16000000 -DHFUSE=hexDE -DLFUSE=hexFF -DBOOT_PAGE_LEN=512 \
 -DVerboseLev=2 -c -o optiboot.o optiboot.S

--------------------------------------------------------------------------------
BAUD RATE CHECK: Desired: 115200,  Real: 117647, UBRR = 16, Difference=2.12%
--------------------------------------------------------------------------------
# # # # # # # # # # # # # # # # # # # # # #
Boot Loader start address: 0x7E00 = 32256
# # # # # # # # # # # # # # # # # # # # # #

   text    data     bss     dec     hex filename
    488       0       0     488     1e8 optiboot.elf
Requires 1 Boot Page of 512 Bytes, which is 1.5% of Flash Memory
BOOTSZ=3, which means 1 Boot Pages

\end{verbatim}


With no additional option a baudrate of 115200 with a clock frequency of \(16 MHz\) is selected.
For serial output the hardware interface is selected.
You should notice, that the systematic baud rate error is above 2\% with the hardware UART.
The second example with the same processor is done with a software solution for the serial interface.

\begin{verbatim}
optiboot $ make atmega328p SOFT_UART=1

Optiboot for 16000000 Hz (16.00 Mhz) operation with Baudrate 115200 and EEprom \
  support configured.
 >>> Start building for AVR atmega328p:
LED-Pin PB5 use Pin 19-PDIP28 17-TQFP32, with special functions: SCK PCINT5
RX-Pin PD0 use Pin 2-PDIP28 30-TQFP32, with special functions: PCINT16 RXD
TX-Pin PD1 use Pin 3-PDIP28 31-TQFP32, with special functions: PCINT17 TXD
avr-gcc -g -Wall -Os -fno-split-wide-types -mrelax -mmcu=atmega328p \
 -fno-diagnostics-show-caret -DBAUD_RATE=115200 -DLED_START_FLASHES=3 \
 -DSUPPORT_EEPROM=1 -DLED=pB5 -DUART=00 -DSOFT_UART=01 -DUART_RX=pD0 -DUART_TX=pD1 \
 -DF_CPU=16000000 -DHFUSE=hexDE -DLFUSE=hexFF -DBOOT_PAGE_LEN=512 \
 -DVerboseLev=2 -c -o optiboot.o optiboot.S

--------------------------------------------------------------------------------
BAUD RATE CHECK: Desired: 115200, SoftUART_Real: 115107, Delay: 116*1, Difference=-.07%
--------------------------------------------------------------------------------
# # # # # # # # # # # # # # # # # # # # # #
Boot Loader start address: 0x7E00 = 32256
# # # # # # # # # # # # # # # # # # # # # #

   text    data     bss     dec     hex filename
    506       0       0     506     1fc optiboot.elf
Requires 1 Boot Page of 512 Bytes, which is 1.5% of Flash Memory
BOOTSZ=3, which means 1 Boot Pages

\end{verbatim}

Please note, that the software solution for the serial interface requires a little more flash memory,
but take use of only 1 boot page too. The systematic baud rate error is much smaller than the error with the hardware UART.
But the hardware UART has the advantage, that the input and output could be done simultaneous and is more tolerant against
short disturbance of the input signal.
For the software serial interface you can specify every digital IO-pin for input (UART\_RX) and output (UART\_TX). 
In this example the feature is used to automatically select the RX and TX of the hardware UART.
Please ignore the three warning messages, which tell you about the automatic selection.
The automatic IO-pin selection depends on the selected processor type and the selected UART number, if more than
one UART is available.


The last examples shows a configuration with the new automatic selection of the baud rate
by measuring the rate of the first incoming data.
The flashing of the LED at the program start is deselected in the first example to save flash memory.

\begin{verbatim}
optiboot $ make atmega328p LED_START_FLASHES=0 BAUD_RATE=52

Optiboot for 16000000 Hz (16.00 Mhz) operation with Auto-Baudrate and EEprom \
  support configured.
 >>> Start building for AVR atmega328p:
LED-Pin not used!
RX-Pin PD0 use Pin 2-PDIP28 30-TQFP32, with special functions: PCINT16 RXD
TX-Pin PD1 use Pin 3-PDIP28 31-TQFP32, with special functions: PCINT17 TXD
avr-gcc -g -Wall -Os -fno-split-wide-types -mrelax -mmcu=atmega328p \
 -fno-diagnostics-show-caret -DBAUD_RATE=52 -DLED_START_FLASHES=0 \
 -DSUPPORT_EEPROM=1 -DLED=p -DUART=00 -DSOFT_UART=0 -DUART_RX=pD0 -DUART_TX=pD1 \
 -DF_CPU=16000000 -DHFUSE=hexDE -DLFUSE=hexFF -DBOOT_PAGE_LEN=512 \
 -DVerboseLev=2 -c -o optiboot.o optiboot.S

--------------------------------------------------------------------------------
Simple Baudrate measurement with time limit implemented in optiboot! (4-bit, CLK/8)
UART Minimum 976 Baud, Difference surely less than 4% up to 160.0 kBaud
--------------------------------------------------------------------------------
# # # # # # # # # # # # # # # # # # # # # #
Boot Loader start address: 0x7E00 = 32256
# # # # # # # # # # # # # # # # # # # # # #

   text    data     bss     dec     hex filename
    498       0       0     498     1f2 optiboot.elf
Requires 1 Boot Page of 512 Bytes, which is 1.5% of Flash Memory
BOOTSZ=3, which means 1 Boot Pages

\end{verbatim}


for the last example the most complex methode of baud rate measurement
was selected because the limit of 512 byte would be exceeded with
selecting the LED flashing and the simplest measurement method (534 byte).

\begin{verbatim}
optiboot $ make atmega328p BAUD_RATE=76

Optiboot for 16000000 Hz (16.00 Mhz) operation with Auto-Baudrate and EEprom \
  support configured.
 >>> Start building for AVR atmega328p:
LED-Pin PB5 use Pin 19-PDIP28 17-TQFP32, with special functions: SCK PCINT5
RX-Pin PD0 use Pin 2-PDIP28 30-TQFP32, with special functions: PCINT16 RXD
TX-Pin PD1 use Pin 3-PDIP28 31-TQFP32, with special functions: PCINT17 TXD
avr-gcc -g -Wall -Os -fno-split-wide-types -mrelax -mmcu=atmega328p \
 -fno-diagnostics-show-caret -DBAUD_RATE=82 -DLED_START_FLASHES=3 \
 -DSUPPORT_EEPROM=1 -DLED=pB5 -DUART=00 -DSOFT_UART=0 -DUART_RX=pD0 -DUART_TX=pD1 \
 -DF_CPU=16000000 -DHFUSE=hexDE -DLFUSE=hexFF -DBOOT_PAGE_LEN=512 \
 -DVerboseLev=2 -c -o optiboot.o optiboot.S

--------------------------------------------------------------------------------
Complex Baudrate measurement implemented in optiboot! (4-bit, CLK/1)
UART Minimum 2197 Baud, Difference surely less than 4% up to 160.0 kBaud
--------------------------------------------------------------------------------
# # # # # # # # # # # # # # # # # # # # # #
Boot Loader start address: 0x7C00 = 31744
# # # # # # # # # # # # # # # # # # # # # #

   text    data     bss     dec     hex filename
    612       0       0     612     262 optiboot.elf
Requires 2 Boot Pages, 512 Bytes each, which is 3.1% of Flash Memory
BOOTSZ=2, which means 2 Boot Pages

\end{verbatim}


\section{Clock Frequency Correction of the internal RC-Generator}

The use of the serial interface is only possible, if the selected baudrate is
matched by both interfaces with only two percent deviation.
The actual baudrate is given by the processor clock and the selected scaling factor for
the serial IO-clock. 
The hardware UART interface scaled the processor clock with factor 8 or 16 and a
additional selectable divider between 1:1 and 1:4096 for generating the clock
for the serial IO.
For lower baudrates additional dividers with power of 2 can be additional selected.
If the relationship between the processor clock and the baudrate clock is
sufficiently high, the desired baudrate can be selected with low deviation.
By generating the optiboot bootloader code the systematic error is shown
at the terminal protocol.
Usually errors lower than 2\% are uncritical.
The implemented coding of the serial interface with software (SOFT\_UART) produce
lower systematic errors as the hardware UART.
The problems with the software solution of the serial interface is caused with
no filter for input data and the missing feature to organize the interface
full duplex. From the output of the last bit to the ability to receive
the next data is allways a little time delay.
For this reason you can expect fewer difficulties with lower baudrates for
the software UART.
All this considerations assume however, that the processor clock itself is
selected with sufficient accuracy.
With a crystal or ceramic resonator the clock frequency is usually accurate enough
without special activities. But for the internal RC-generator of the AVR processors
the situation is different.
The actual processor clock can differ too much from the desired value.
The processors are precalibrated at factory. But this calibration is
valid only for one temperature and operating voltage.
The sensivity of frequency changes with temperature and operating voltage
differ for the different processor types.
To enable a correction for the user of the processor, the calibration value
of the clock frequency is copied to a special IO register with the name OSCCAL
at every start of the processor.
The Optiboot bootloader can use the option OSCCAL\_CORR to correct a
known residual error of the clock frequency.

If the actual clock rate is uncritical for your application and you
can spend the additional memory space to the bootloader,
you can also use the automatic baud rate selection of optiboot.
The automatic baud rate selection is implemented by the optiboot bootloader,
if you select a baud rate below 100 at the generation time.
You can find more details about the automatic baud rate selection in
subsection~\ref{sec:autobaud} at page~\pageref{sec:autobaud}.
But you should keep in mind, that the deviation to the expected clock rate
will also affect the application program ( if it will use a serial interface).

In the following subsections I have analysed the correction of the
RC clock frequency for some AVR examples.


\subsection{RC-generators check of the ATmega8}

The Atmega8 can select 4 different frequencies for the internal RC generator
with the Low-fuse, \(1MHz\), \(2MHz\), \(4MHz\) and \(8MHz\).
In the table~\ref{tab:mega8freq} I have analysed all 4 selections.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | c || c | c || c | c || c | c |}
    \hline
    AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
             FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
                1M & 0xA1  &  9.6k &  -8  & 1050k &  4  & 983k  & 0  & 1004k \\
    \hline
                2M & 0xA2  & 19.2k &  -8  & 2098k &  4  & 1967k & 0  & 2008k \\
    \hline
                4M & 0xA3  & 19.2k &  -2  & 4201k & 10  & 3927k & 7  & 3999k \\
    \hline
                8M & 0xA4  & 57.6k &   0  & 8231k & 13  & 7723k & 6  & 7990k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the RC-frequencies of the ATmega8}
  \label{tab:mega8freq}
\end{table}

The table~\ref{tab:mega8freq} shows, that for the \(1Mhz\) and \(2MHz\) operation a correction of the
OSCCAL register is not required. This ATmega8 is calibrated for these frequencies
very good at the factory.
For the \(4MHz\) clock frequency a operation without correction is still possible,
but the correct clock frequency is better approximated with a OSCCAL\_CORR value of 7.
For the \(8MHz\) clock frequency the serial interface was still possible
withou the correction, but the serial interface runs more safely with
the OSCCAL\_CORR value 6.

\subsection{RC-Generators check of the ATmega8535}

The ATmega8535 can select 4 different frequencies for the internal RC generator
with the Low-fuse, \(1MHz\), \(2MHz\), \(4MHz\) and \(8MHz\).
The table~\ref{tab:mega8535freq} shows the results for one example for
all 4 frequencies.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | c || c | c || c | c || c | c |}
    \hline
    AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
             FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
                1M & 0xA1  &  9.6k &  -10  & 1053k &  3  & 982k  & 0  & 1001k \\
    \hline
                2M & 0xA2  & 19.2k &  -9  & 2095k &  4  & 1965k & 1  & 1998k \\
    \hline
                4M & 0xA3  & 19.2k &  -5  & 4204k &  8  & 3932k & 4  & 4012k \\
    \hline
                8M & 0xA4  & 19.2k &  -7  & 8420k &  6  & 7901k & 3  & 8003k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the RC-frequencies of the ATmega8535}
  \label{tab:mega8535freq}
\end{table}

\subsection{RC-Generators check of the ATmega8515 and the ATmega162}

The ATmega8515 can select 4 different frequencies for the internal RC generator
with the Low fuse, \(1MHz\), \(2MHz\), \(4MHz\) and \(8MHz\).
The table~\ref{tab:mega8515freq} shows the results of one exemplar 
for all 4 frequency selections.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | c || c | c || c | c || c | c |}
    \hline
    AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
             FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
                1M & 0xA1  &  9.6k &  -10  & 1053k &  2  & 985k  & -1  & 997k \\
    \hline
                2M & 0xA2  & 19.2k &  -10  & 2099k &  3  & 1963k & -1  & 1999k \\
    \hline
                4M & 0xA3  & 38.4k &  -3  & 4192k &  10  & 3928k & 7  & 3979k \\
    \hline
                8M & 0xA4  & 38.4k &  -3  & 8396k &  10  & 7860k & 7  & 7966k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the RC-frequencies of the ATmega8515}
  \label{tab:mega8515freq}
\end{table}

The ATmega162 with a simular pin layout can only operate with the
\(8MHz\) RC generator frequency.
Table~\ref{tab:mega162freq} shows the result of one exemplar.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | c || c | c || c | c || c | c |}
    \hline
    AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
             FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
                8M & 0xE2  & 38.4k &  0  & 8190k &   6  & 7718k & 2  & 8000k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the RC-oscillator of the ATmega162}
  \label{tab:mega162freq}
\end{table}


\subsection{RC-Generators check of the ATmega328 family}

For the ATmega328 family only a RC oscillator frequency of \(8MHz\) can be selected.
This Frequency can be divided by factor 8 with a fuse-bit, so that a
operation with \(1MHz\) can be also selected.
The table~\ref{tab:mega328freq} shows the results for the checked processors.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| l | c | c | c || c | c || c | c || c | c |}
    \hline
    Typ & AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
        &       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
mega48P &          8M & 0xE2  & 57.6k &  -6  & 8230k &  8  & 7720k  & 0  & 8010k \\
    \hline
mega88 &          8M & 0xE2  & 57.6k &  -2  & 8250k & 10  & 7770k  & 4  & 7990k \\
    \hline
mega168 &          8M & 0xE2  & 57.6k &  -5  & 8263k &  8  & 7720k  & 1  & 7970k \\
    \hline
mega328P &          8M & 0xE2  & 57.6k &  -5  & 8250k &  9  & 7723k  & 1  & 7992k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the ATmega328 family}
  \label{tab:mega328freq}
\end{table}

For all checked processors the serial interface can be used with the internal
RC generator without any OSCCAL correction.
Only for the checked ATmega88 a correction would be worthwhile (OSCCAL\_CORR=4).

\subsection{RC-Generators check of the ATmega32 / 16}

You can select 4 different frequencies with the internal RC-generator for
the ATmega32 and the ATmega16, \(1MHz\), \(2MHz\), \(4MHz\) and \(8MHz\).
The tables~\ref{tab:mega32freq} and \ref{tab:mega16freq} shows the results
with one test exemplar each.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | c | c || c | c || c | c || c | c |}
    \hline
       & AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
 Typ    &     FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
m32  &       1M    & 0xA1  &  9.6k &  -13  & 1049k & -1  & 980k  & -5  & 1001k \\
m32a &             &       &       &  -7  & 1046k &  4  & 984k  & 1  & 998k \\
    \hline
m32  &       2M    & 0xA2  & 19.2k &  -12  & 2102k &  0  & 1968k & -3  & 1997k \\
m32a &             &       &       &  -7  & 2105k &  6  & 1966k & 2  & 2005k \\
    \hline
m32  &       4M    & 0xA3  & 19.2k &  -5  & 4169k & 6  & 3942k & 3  & 3993k \\
m32a &             &       &       &   2  & 4192k & 14  & 3939k & 10  & 4015k \\
    \hline
m32  &       8M    & 0xA4  & 19.2k &  -7  & 8425k &  6  & 7888k & 3  & 7983k \\
m32a &             &       &       &   2  & 8408k & 14  & 7921k & 11  & 8014k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the RC-frequencies of the ATmega32}
  \label{tab:mega32freq}
\end{table}

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | c || c | c || c | c || c | c |}
    \hline
       AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
             FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
                1M & 0xA1  &  9.6k &  -11  & 1047k &  1  & 982k  & -2  & 998k \\
    \hline
                2M & 0xA2  & 19.2k &  -12  & 2099k &  0  & 1971k & -3 & 1995k \\
    \hline
                4M & 0xA3  & 19.2k &  -9  & 4291k &  3  & 3932k & 0  & 4002k \\
    \hline
                8M & 0xA4  & 19.2k &  -11 & 8415k & 2  & 7857k & -2  & 8013k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the RC-frequencies of the ATmega16}
  \label{tab:mega16freq}
\end{table}

Whenever positive values appear in the MinCorr column or negative values in the MaxCorr
column, it is impossible to use the serial interface with this processor at this frequency 
without a frequency correction.
If a 0 appear in any of the Corr columns, the operation of the serial interface
is just possible.

\subsection{RC-Generator check of the ATmega163L}

The ATmega163L has only one \(1MHz\) RC-generator, which can be adjusted
with the OSCCAL register.
My exemplar had no preselection of the OSCCAL value.
Therefore, exceptiionally high correction values are required to select
a clock frequency of about \(1MHz\).

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | c || c | c || c | c || c | c |}
    \hline
       AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
             FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
                1M & 0x92  &  9.6k &  -88  & 1026k &  -62  & 964k  & -77  &  998k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the RC-frequency of the ATmega163L}
  \label{tab:mega163freq}
\end{table}

\subsection{RC-Generator check of the ATmega64 / 128}

The ATmega64 and the ATmega128 can select 4 different frequencies for the
internal RC-generator with the Low-fuse, \(1MHz\), \(2MHz\), \(4MHz\) and \(8MHz\).
In then tables~\ref{tab:mega64freq} and \ref{tab:mega128freq} all 4 frequencies
are checked.
At this point it should also be noticed, that the program data is loaded via the ISP
interface not with the signals MISO and MOSI but via the signals TXD (PE1) and
RXD (PE0). Of course this must be taken into account when connecting the
processor to the programmer.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | c || c | c || c | c || c | c |}
    \hline
       AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
             FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
                1M & 0xA1  &  9.6k &  -4  & 1024k &  6  & 975k  & 1  & 1000k \\
    \hline
                2M & 0xA2  & 19.2k &  -4  & 2047k &  6  & 1952k & 0  & 2015k \\
    \hline
                4M & 0xA3  & 19.2k &   4  & 4070k & 10  & 3939k & 8  & 3976k \\
    \hline
                8M & 0xA4  & 57.6k &   6  & 8028k & 10  & 7847k & 7  & 8005k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the RC-frequencies of the ATmega64}
  \label{tab:mega64freq}
\end{table}

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | c || c | c || c | c || c | c |}
    \hline
       AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
             FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
                1M & 0xA1  &  9.6k &  -9  & 1051k &  3  & 985k  & 0  &  999k \\
    \hline
                2M & 0xA2  & 19.2k &  -9  & 2102k &  3  & 1971k & 0  & 2000k \\
    \hline
                4M & 0xA3  & 19.2k &  -3  & 4209k &  9  & 3960k & 6  & 4006k \\
    \hline
                8M & 0xA4  & 57.6k &   0  & 8225k & 13  & 7723k & 7  & 8005k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the RC-frequencies of the ATmega128}
  \label{tab:mega128freq}
\end{table}

You can see at the tables, that there is no correction of the OSCCAL register necessary 
at \(1MHz\) and \(2MHz\) operation for using the serial interface.
For operation at \(4MHz\) or \(8MHz\) the checked ATmega64 can not use
the serial interface without a frequency correction.
The \(4MHz\) frequency is about 4\% too high Without the correction and
the \(8MHz\) frequency is about 4.3\% too high.
You can find a hint in the Atmel documentation, that the RC-generator of the
ATmega64 and ATmega128 is calibrated at \(1MHz\).
It should be noted once again, that the the tabular data is the test result of a single copy
of the ATmega. Outside the specified minimum or maximum values of the OSCCAL-corrections,
it was not possible to operate the serial interface at thespecified baud rate.

\subsection{RC-Generator check of the ATmega644 family}

For the ATmega644 family an RC oscillator frequency of \(8MHz\) can be selected.
In addition a \(128kHz\) generator can be selected as the clock, which
otherwise supplies the watchdog timer.
The selected frequency can be pre-divided with a factor 8 fuse bit,
so that a \(1MHz\) operation is also possible.
The table~\ref{tab:mega644freq} shows the results for the checked processors.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| l | c | c | c || c | c || c | c || c | c |}
    \hline
   Typ & AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
        &       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
mega1284p &          8M & 0xC2  & 19.2k & -8  & 8416k & 7  & 7882k  & 4  & 7989k \\
    \hline
mega644p &          8M & 0xC2  & 19.2k &  -12 & 8416k & 3  & 7871k  & -1  & 8009k \\
    \hline
mega324p &          8M & 0xC2  & 19.2k &  -12 & 8398k & 3  & 7885k  & 0  & 7976k \\
    \hline
mega164p &          8M & 0xC2  & 19.2k &  -5  & 8401k & 4  & 7888k  & 2  & 8012k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the ATmega644 family}
  \label{tab:mega644freq}
\end{table}

\subsection{RC-Generator check of the ATmega645 family}

For the ATmega645 family an RC oscillator frequency of \(8MHz\) can be selected.
Bei der ATmega645 Familie kann nur eine RC-Oszillatorfrequenz von 8MHz gew√§hlt werden.
The selected frequency can be pre-divided with a factor 8 fuse bit,
so that a \(1MHz\) operation is also possible.
The table~\ref{tab:mega645freq} shows the results for the checked processors.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| l | c | c | c || c | c || c | c || c | c |}
    \hline
   Typ & AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
        &       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
mega165p &         8M & 0xE2  & 57.6k & -6  & 8235k &  7  & 7718k  & -1  & 8015k \\
    \hline
mega325  &         8M & 0xE2  & 38.4k & -10 & 8403k &  5  & 7868k  &  1  & 7992k \\
    \hline
mega645 &          8M & 0xE2  & 57.6k &  0  & 8253k & 12  & 7726k  & 5  & 8012k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the ATmega645 family}
  \label{tab:mega645freq}
\end{table}

Beim ATmega645 ist der Betrieb der seriellen Schnittstelle ohne OSCCAL Korrektur gerade noch m√∂glich.
Sicherer ist aber der Betrieb mit OSCCAL\_CORR=5, da dann die 8MHz besser eingehalten werden. 

\subsection{RC-Generator check of the ATmega649 family}

For the ATmega649 family an RC oscillator frequency of \(8MHz\) can be selected.
The selected frequency can be pre-divided with a factor 8 fuse bit,
so that a \(1MHz\) operation is also possible.
The table~\ref{tab:mega649freq} shows the results for the checked processors.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| l | c | c | c || c | c || c | c || c | c |}
    \hline
   Typ & AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
        &       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
mega169 &          8M & 0xE2  & 57.6k &  -9  & 8250k & 2  & 7864k  & -2  & 8010k \\
    \hline
mega329 &          8M & 0xE2  & 38.4k &  -2  & 8330k & 7  & 7877k  &  4  & 8013k \\
    \hline
mega649 &          8M & 0xE2  & 38.4k &  -2  & 8370k & 8  & 7895k  &  6  & 7988k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the ATmega649 family}
  \label{tab:mega649freq}
\end{table}

\subsection{RC-Generator check of the ATmega2560 family}

For the ATmega2560 family an RC oscillator frequency of \(8MHz\) can be selected.
The selected frequency can be pre-divided with a factor 8 fuse bit,
so that a \(1MHz\) operation is also possible.
The table~\ref{tab:mega2560freq} shows the results for the checked processors.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| l | c | c | c || c | c || c | c || c | c |}
    \hline
   Typ & AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
        &       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
mega1281 &          8M & 0xC2  & 38.4k &  -5 & 8405k & 5 & 7871k   & 2  &  8012k \\
    \hline
mega2561 &          8M & 0xC2  & 38.4k &  -8 & 8363k & 4  & 7870k  & 1  & 7990k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the ATmega2560 family}
  \label{tab:mega2560freq}
\end{table}

Loading of more than 128Kbyte data was successfully tested with the ATmega2561.
Normally the user data for the flash memory starts withh the address 0.
This is not absolutely nessesary for data download via the serial interface.
But the initial address must be below 128K (0x20000), so that the loading
of data into the upper flash memory half works.
The option VIRTUAL\_BOOT\_PARTITION can not be used by processors with
more than 128Kbyte flash memory.

\subsection{RC-Generator check of the ATtiny4313 family}

The ATtiny4313 und the ATtiny2313 can select a RC-generator frequency of
\(8MHz\) and \(4MHz\) with the Low-fuse.
In addition a \(128kHz\) generator can be selected as the clock, which
otherwise supplies the watchdog timer.
The table~\ref{tab:tiny4313freq} shows the results of the frequeny measurement
at \(4MHz\) and \(8MHz\) operation for the checked processors.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| l | c | c | c || c | c || c | c || c | c |}
    \hline
   Typ & AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
        &       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
tiny4313 &         8M & 0xE4  & 38.4k &  -4  & 8342k & 0  & 7975k  & -1  & 7983k \\
         &            &       &       &  -2  & 8326k & 3  & 7905k  & 1  & 8010k \\
    \hline
tiny2313 &         8M & 0xE4  & 38.4k &  -4  & 8400k & 3  & 7909k  &  2  & 7980k \\
    \hline
tiny4313 &         4M & 0xE2  & 38.4k &  -6  & 4193k & -3  & 3976k  & -3  & 3976k \\
         &            &       &       &   1  & 4169k & 6  & 3961k  & 5  & 4017k \\
    \hline
tiny2313 &         4M & 0xE2  & 38.4k &   0  & 4160k & 6  & 3960k  &  5  & 3998k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the ATtiny4313 family}
  \label{tab:tiny4313freq}
\end{table}

For all three checked ATtinys of this series the setting of the frequency was difficult
because a small OSCCAL correction results to a relatively strong frequency change.


\subsection{RC-Generator check of the ATtiny84 family}

The ATtiny84 family can select the \(128kHz\) clock of the watch dog additional
to the \(8MHz\) internal RC-generator as the main clock.
But the \(128kHz\) clock can not be adjusted. If you use this clock,
you can only correct the generated baud rate by selecting another baud rate value
or you can use the automatic baud rate selection.
For a ATtiny24a I have checked the generated baud rate. Instead of the selected
2400 Baud I could measure only 2170 Baud.
This results to a frequency error of about 9.6\%, which is much too high for
using it without a correction.
If I select a baud rate of 2640 Baud for the optiboot, the download could operate with 
2400 Baud. The measured clock frequency of the processor was \(115.2kHz\) instead
of the \(128kHz\).
The table~\ref{tab:tiny84freq} shows the results of the frequeny measurement
at the \(8Mhz\) operation for the checked processors.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| l | c | c | c || c | c || c | c || c | c |}
    \hline
   Typ & AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
        &       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
attiny84 &          8M & 0xE2  & 19.2k &  -6  & 8453k & 14  & 7673k  & 5  & 8019k \\
    \hline
attiny44a &         8M & 0xE2  & 19.2k &  -16  & 8367k & 3  & 7673k  & -7  & 7984k \\
    \hline
attiny24a &         8M & 0xE2  & 19.2k &  -4  & 8388k & 11  & 7685k  & 4  & 7992k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the ATtiny84 family}
  \label{tab:tiny84freq}
\end{table}

\subsection{RC-Generators check of the ATtiny85 family}

The ATtiny84 family can select a \(8MHz\) and a \(6.4MHz\) RC-generator and
a \(128kHz\) clock of the watchdog circuit.
The \(6.4MHz\) RC-generator clock is allways scaled to \(1.6Mhz\) for
the processor clock.
The \(128kHz\) clock can not be calibrated. If you wish to use this clock,
you can adjust the baud rate only by selecting a corrected baud rate value
or you can use the automatic baud rate selection.
The first table~\ref{tab:tiny85freq8} shows the results of the frequeny measurement
at the \(8Mhz\) operation for the checked processors.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| l | c | c | c || c | c || c | c || c | c |}
    \hline
   Typ & AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
        &       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
attiny85 &          8M & 0xE2  & 38.4k &  -4  & 8370k &  9  & 7714k  & 3  & 8012k \\
    \hline
attiny45  &         8M & 0xE2  & 38.4k &  -4  & 8400k & 9  & 7706k  & 3  & 8030k \\
    \hline
attiny25  &         8M & 0xE2  & 38.4k &  -9  & 8424k & 46  & 7724k  & 40  & 8034k \\
attiny25  &         8M & 0xE2  & 38.4k &  -12  & 8399k & 7  & 7680k  & -2  & 7992k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the ATtiny85 family at \(8MHz\) operation}
  \label{tab:tiny85freq8}
\end{table}

The setting values for the ATtiny25 look strange, but in the case of correction 3
the OSCCAL value has fallen below the number 128 and is therefore in a different
setting range.
Not before a correction value of 34 a frequency of \(8364kHz\) was reached again,
at which a operation of the serial interface was possible.
A simular frequency could be selected with the correction value -6 in the other
setting range.
The next table~\ref{tab:tiny85freq1} shows the results of the frequeny measurement
at the \(1.6Mhz\) operation for the checked processors.
The RC-generator operates at \(6.4Mhz\), but this frequency is allways divided
ba factor 4 for the processor.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| l | c | c | c || c | c || c | c || c | c |}
    \hline
   Typ & AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
        &       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
attiny85 &         1.6M & 0xD3  & 9.6k &  -7  & 1684k &  9  & 1547k  & 2  & 1603k \\
    \hline
attiny45  &        1.6M & 0xD3  & 9.6k &  -5  & 1684k & 11  & 1559k  & 4  & 1603k \\
    \hline
attiny25  &        1.6M & 0xD3  & 9.6k &  -7   & 1689k & 10 & 1543k  & 3  & 1602k \\
attiny25  &        1.6M & 0xD3  & 9.6k &  -10  & 1680k & 3  & 1550k  & -3  & 1609k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the ATtiny85 family at \(1.6MHz\) operation}
  \label{tab:tiny85freq1}
\end{table}

The operation with \(1.6MHz\) clock frequency has not shown the anomaly of the
OSCCAL setting for the ATtiny25.
All checked examples can use the serial interface without any correction
at this frequency.
The ATtiny84 processor family can also use a PLL-oscillator, which is controlled
with the internal \(8MHz\) RC generator. The PLL-oscillator can operate at
\(64MHz\) or at \(32MHz\) clock, which is typically used for the T1 counter.
If you use the PLL-clock for the processor, you can only select the \(64MHz\) operation
and the clock is scaled by factor 4. So you will get a resulting \(16MHz\) clock
for the processor.
The table~\ref{tab:tiny85freq16} shows the measured results.
As expected, these results do not differ significantly from the \(8MHz\) results.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| l | c | c | c || c | c || c | c || c | c |}
    \hline
   Typ & AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
        &       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
attiny85 &         16M & 0xF1  & 38.4k &  -4  & 16.87M &  10  & 15.41M  & 4  & 16.02M \\
    \hline
attiny45  &        16M & 0xF1  & 38.4k &  -4  & 16.87M & 10  & 15.41M  & 4  & 15.95M \\
    \hline
attiny25  &        16M & 0xF1  & 38.4k &  -9   & 16.91M & 47 & 15.38M  & 41  & 16.03M \\
attiny25  &        16M & 0xF1  & 38.4k &  -11  & 16.82M & 7  & 15.43M  & -2  & 16.07M \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the ATtiny85 family at \(16MHz\) operation}
  \label{tab:tiny85freq16}
\end{table}

\subsection{RC-Generators check of the ATtiny841 family}

The ATtiny841 and the ATtiny441 can use also a internal \(8MHz\) RC-generator,
which can be adjusted.
For the support of this family some special modifications must be done
at the optiboot bootloader source.
The table~\ref{tab:tiny841freq8} shows the results of some checked examples.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| l | c | c | c || c | c || c | c || c | c |}
    \hline
   Typ & AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
        &       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
attiny841 &          8M & 0xE2  & 38.4k &  -4  & 8369k & 10  & 7861k  & 6  & 8003k \\
          &             &       &       &  -5  & 8389k &  9  & 7874k  & 6  & 7990k \\
    \hline
attiny441  &         8M & 0xE2  & 38.4k &  -4  & 8399k & 10 & 7870k  & 7  & 7985k \\
           &            &       &       &  -4  & 8380k &  9 & 7900k  & 7  & 7985k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the ATtiny841 family at \(8MHz\) operation}
  \label{tab:tiny841freq8}
\end{table}

For all checked examples the serial interface can be used without the
OSCCAL correction.


\subsection{RC-Generators check of the ATtiny861 family}

The ATtiny861 family can use a \(8MHz\) internal RC generator, a PLL oscillator
and the \(128kHz\) clock of the watchdog circuit.
The \(128kHz\) clock of the watchdog circuit can not be calibrated und is
therefore limited for use with the bootloader application.
The PLL-Oscillator has a resulting frequency of \(16MHz\) for the processor,
which can only synchronized by the internal RC-generator.
Therefore you can not use the PLL-oscillator with the T1 counter
for precise time measurements.
The first table~\ref{tab:tiny861freq8} shows the OSCCAL correction results of the checked examples
for the \(8MHz\) operation.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| l | c | c | c || c | c || c | c || c | c |}
    \hline
   Typ & AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
        &       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
attiny861 &          8M & 0xE2  & 38.4k &  -2  & 8415k & 18  & 7693k  & 9  & 8007k \\
          &             &       &       &  -1  & 8436k & 19  & 7678k  & 10 & 8011k \\
    \hline
attiny461  &         8M & 0xE2  & 38.4k &  -2  & 8418k & 17 & 7690k  & 9  & 7995k \\
           &            &       &       &  -4  & 8380k & 14 & 7695k  & 5  & 8030k \\
    \hline
attiny261  &         8M & 0xE2  & 38.4k &  -4  & 8403k & 17 & 7710k  & 9  & 7986k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the ATtiny861 family at \(8MHz\) operation}
  \label{tab:tiny861freq8}
\end{table}

For the ATtiny261 I have omitted the optional LED-flashing at the start of the optiboot
to get enough space for the test program (option LED\_START\_FLASHES=0).


\subsection{RC-Generators check of the ATtiny87 family}

The ATtiny87 family can select a internal \(8MHz\) RC-generator and a
internal \(128kHz\) generator as processor clock.
You can also select a factor 8 scaler for the processor clock with the Low-fuse.
The table~\ref{tab:tiny87freq} shows the calibration results of two examples of this family.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| l | c | c | c || c | c || c | c || c | c |}
    \hline
  Typ & AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
        &       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
attiny87 &          8M & 0xE2  & 57.6k &  -1  & 8270k & 7  & 7940k  & 3  & 8035k \\
    \hline
attiny167 &         8M & 0xE2  & 57.6k &  -5  & 8227k & 2  & 7839k  & -1  & 8009k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the ATtiny87 family}
  \label{tab:tiny87freq}
\end{table}


\subsection{RC-Generators check of the ATtiny88 family}

The ATtiny88 family can select a internal \(8MHz\) RC-generator and a
internal \(128kHz\) generator as processor clock.
You can also select a factor 8 scaler for the processor clock with the Low-fuse.
The table~\ref{tab:tiny88freq} shows the calibration results of two examples of this family.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| l | c | c | c || c | c || c | c || c | c |}
    \hline
   Typ & AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
        &       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
attiny88 &          8M & 0xE2  & 38.4k &  -4  & 8397k & 15  & 7682k  & 6  & 8013k \\
    \hline
attiny48 &         8M & 0xE2  & 38.4k &  -5  & 8385k & 12  & 7739k  & 5  & 7995k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the ATtiny88 family}
  \label{tab:tiny88freq}
\end{table}

Both examples can operate the serial interface without a frequency correction.
But the processor clock will match the \(8MHz\) better, if you choose
a correction value of 5 (6).

\subsection{RC-Generator check of the ATtiny1634}

I have checked the \(8MHz\) internal RC-generator of the ATtiny1634
with two examples.
The ATtiny1634 support two additional calibration register for adjusting the
temperature drift of the \(8MHz\) RC-generator.
In the table~\ref{tab:tiny1634freq} I have not checked the effect of
the temperature drift compensation.
Additional to the \(8MHz\) RC-generator the ATmega1634 can also adjust
the internal \(32kHz\) generator with a additional calibration register (OSCCAL1).
This adjustment is currently unsupported by the Optiboot bootloader.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| c | c | c || c | c || c | c || c | c |}
    \hline
    AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
         8M & 0xE2  & 19.2k &  -5  & 8404k &  9  & 7867k  & 6  & 7983k \\
         8M & 0xE2  & 19.2k &  -7  & 8410k &  7  & 7867k  & 4  & 7986k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the ATtiny1634}
  \label{tab:tiny1634freq}
\end{table}

\subsection{RC-Generators check of the AT90PWM family}

Beside the usual \(8MHz\) internal RC-generator the AT90PWM family can also
select a PLL-oscillator with a resulting processor clock of \(16MHz\).
The PLL-oscillator is synchronized by the internal \(8MHz\) RC-generator.
The table~\ref{tab:t90pwmfreq} shows the OSCCAL correction results
of two examples.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| l | c | c | c || c | c || c | c || c | c |}
    \hline
   Typ & AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
        &       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
at90pwm2b &         8M & 0xE2  & 38.4k &  -13  & 8350k & -1  & 7862k  & -5  & 8020k \\
    \hline
at90pwm3  &         8M & 0xE2  & 38.4k &  -10  & 8359k &  4  & 7885k  & 1  & 7991k \\
    \hline
at90pwm2b &        16M & 0xE3  & 38.4k &  -14  & 16.74M & -1  & 15.74M  & -4  & 15.97M \\
    \hline
at90pwm3  &        16M & 0xE3  & 38.4k &  -10  & 16.79M &  4  & 15.79M  & 2  & 15.97M \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the AT90PWM family}
  \label{tab:t90pwmfreq}
\end{table}

The AT90PWM2B can not use the serial interface without a OSCCAL correction.

\subsection{RC-Generators check of the AT90CAN family}

I have examined only one copy of a AT90CAN32 and AT90CAN132.
Both AT90CAN examples can only select one internal \(8~MHz\) RC-oscillator.
All other choises require an external crystal or external clock generator.
The clock frequency can optionally be divided by the factor 8,
so that also a \(1~MHz\) operation is possible with the internal clock.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{| l | c | c | c || c | c || c | c || c | c |}
    \hline
   Typ & AVR\_ & LFUSE & Baud- & \multicolumn{2}{c ||}{Minimum} & \multicolumn{2}{c ||}{Maximum} & \multicolumn{2}{c |}{Best}  \\
        &       FREQ  &       & rate & Corr & Freq & Corr & Freq  & Corr  & Freq  \\
    \hline
    \hline
at90can32 &         8M & 0xE2  & 38.4k &  0  & 8379k & 6  & 7920k  & 5  & 8019k \\
    \hline
at90can128 &         8M & 0xE2  & 38.4k &  0  & 8303k &  3  & 7922k  & 2  & 8057k \\
    \hline
    \end{tabular}
  \end{center}
  \caption{Possible OSCCAL\_CORR selections for the AT90CAN family}
  \label{tab:t90canfreq}
\end{table}
